# RESTful API Activity - [Your Name]

## Overview
This is a production-ready REST API for managing restaurant dishes. It demonstrates core REST principles, standardized HTTP responses, environment configuration, and proper resource modeling.

## Project Details
- **Framework**: Express.js
- **Runtime**: Node.js
- **Configuration**: Environment variables (.env)
- **Data Storage**: In-memory mock data
- **Middleware**: CORS, JSON parser

## Installation & Quick Start

### Prerequisites
- Node.js (v14 or higher)
- npm (comes with Node.js)

### Setup Steps

```bash
# 1. Create project directory
mkdir lastname-api-activity
cd lastname-api-activity

# 2. Initialize npm
npm init -y

# 3. Install dependencies
npm install express dotenv cors
npm install --save-dev nodemon

# 4. Create project structure (folders)
mkdir -p src/models src/routes

# 5. Copy all files (see file list above)

# 6. Install git
git init
echo "node_modules/" > .gitignore
echo ".env" >> .gitignore

# 7. Run development server
npm run dev
```

### Running the Server

```bash
npm run dev
```

Expected output:
```
âœ… Server running on http://localhost:3000/api/v1
```

---

## Environment Configuration

### Why use `.env` for configuration?

**Question**: Why did we put `BASE_URI` in `.env` instead of hardcoding it?

**Answer**: 
1. **Flexibility and Versioning**: You can change the API version (e.g., `/api/v2`) without modifying code
2. **Multiple Environments**: Different servers (development, staging, production) can have different configurations
3. **Security Best Practice**: Prevents hardcoding sensitive information or environment-specific details
4. **Maintainability**: Configuration lives in one place; code references it consistently
5. **DevOps Friendly**: CI/CD pipelines can inject variables at deployment time
6. **12-Factor App Methodology**: Industry standard for cloud-native applications

### Current Configuration

```env
PORT=3000              # Server port
BASE_URI=/api/v1       # API endpoint base path
```

---

## Resource Modeling

### Why use plural nouns (e.g., `/dishes`)?

**Question**: Why did we use plural nouns (e.g., `/dishes`) for our routes?

**Answer**:
1. **REST Convention**: Collections are always represented in plural (`/dishes`, `/users`, `/restaurants`)
2. **Immediate Clarity**: Developers instantly know they're accessing a collection of resources
3. **Consistency**: Industry-standard that all API developers follow
4. **Scalability**: Easy to add sub-resources (e.g., `/dishes/:id/reviews`)
5. **Semantic Accuracy**: 
   - `/dishes` = collection of all dishes
   - `/dishes/:id` = single dish resource
6. **API Intuitiveness**: Makes CRUD operations intuitive:
   - `POST /dishes` = add to collection
   - `GET /dishes` = get all
   - `GET /dishes/1` = get one
   - `PUT /dishes/1` = update one
   - `DELETE /dishes/1` = remove one

### Data Model

```javascript
{
  id: 1,
  name: "Chicken Adobo",
  price: 120,
  category: "Main Course"
}
```

---

## HTTP Status Codes & Responses

### Standard Response Format

All API responses follow this structure:

```json
{
  "status": <HTTP_STATUS_CODE>,
  "message": "<descriptive message>",
  "data": <resource_data_or_null>
}
```

### Status Code Usage

**Question**: When do we use `201 Created` vs `200 OK`?

**Answer**:

| Status Code | HTTP Method | Scenario | Example |
|------------|------------|----------|---------|
| **200 OK** | GET, PUT, DELETE | Successful operation that returns data | GET /dishes returns array of dishes |
| **201 Created** | POST | New resource successfully created | POST /dishes creates new dish |
| **400 Bad Request** | Any | Request validation failed (missing/invalid fields) | POST /dishes without name field |
| **404 Not Found** | GET, PUT, DELETE | Requested resource doesn't exist | GET /dishes/999 (ID doesn't exist) |
| **500 Server Error** | Any | Unexpected server error | Database connection failure |

#### Why `201 Created` vs `200 OK`?
- **201 Created**: Specifically signals a new resource was created. Clients know a resource now exists with a new ID
- **200 OK**: Generic success response. Used when returning existing data or confirmation of deletion

### Why `404` instead of empty array or generic error?

**Question**: Why is it important to return `404` instead of just an empty array or a generic error?

**Answer**:
1. **Semantic Accuracy**: `404` specifically means "resource doesn't exist" - no ambiguity
2. **Differentiation**:
   - `404` = Requested dish ID doesn't exist (error condition)
   - `200` with `[]` = No dishes exist yet (normal condition)
3. **Better Debugging**: Developers immediately know the issue is a missing resource
4. **Standards Compliance**: Follows HTTP/REST specifications
5. **Client-Side Handling**: Different logic for:
   - Empty results (might retry, show "no items" UI)
   - 404 (don't retry, show "not found" error)
6. **Error Prevention**: Generic errors hide the actual issue

### Example Response Scenarios

#### GET /api/v1/dishes (Success - 200)
```json
{
  "status": 200,
  "message": "Dishes retrieved successfully",
  "data": [
    { "id": 1, "name": "Chicken Adobo", "price": 120, "category": "Main Course" },
    { "id": 2, "name": "Sinigang", "price": 150, "category": "Soup" }
  ]
}
```

#### GET /api/v1/dishes/1 (Success - 200)
```json
{
  "status": 200,
  "message": "Dish retrieved successfully",
  "data": { "id": 1, "name": "Chicken Adobo", "price": 120, "category": "Main Course" }
}
```

#### POST /api/v1/dishes (Success - 201)
```json
{
  "status": 201,
  "message": "Dish created successfully",
  "data": { "id": 5, "name": "Lechon", "price": 250, "category": "Main Course" }
}
```

#### GET /api/v1/dishes/999 (Not Found - 404)
```json
{
  "status": 404,
  "message": "Dish not found",
  "data": null
}
```

#### POST /api/v1/dishes with missing fields (Bad Request - 400)
```json
{
  "status": 400,
  "message": "Missing required fields: name, price, category",
  "data": null
}
```

---

## API Endpoints

### 1. GET /api/v1/dishes
**Retrieve all dishes**

```bash
curl http://localhost:3000/api/v1/dishes
```

**Response (200 OK)**:
```json
{
  "status": 200,
  "message": "Dishes retrieved successfully",
  "data": [...]
}
```

---

### 2. GET /api/v1/dishes/:id
**Retrieve a single dish by ID**

```bash
curl http://localhost:3000/api/v1/dishes/1
```

**Response (200 OK)**:
```json
{
  "status": 200,
  "message": "Dish retrieved successfully",
  "data": { "id": 1, "name": "Chicken Adobo", "price": 120, "category": "Main Course" }
}
```

**Response (404 Not Found)**:
```json
{
  "status": 404,
  "message": "Dish not found",
  "data": null
}
```

---

### 3. POST /api/v1/dishes
**Create a new dish**

```bash
curl -X POST http://localhost:3000/api/v1/dishes \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Kare-Kare",
    "price": 180,
    "category": "Main Course"
  }'
```

**Request Body**:
```json
{
  "name": "Kare-Kare",
  "price": 180,
  "category": "Main Course"
}
```

**Response (201 Created)**:
```json
{
  "status": 201,
  "message": "Dish created successfully",
  "data": { "id": 5, "name": "Kare-Kare", "price": 180, "category": "Main Course" }
}
```

**Response (400 Bad Request - Missing fields)**:
```json
{
  "status": 400,
  "message": "Missing required fields: name, price, category",
  "data": null
}
```

---

### 4. PUT /api/v1/dishes/:id
**Update entire dish (full update)**

```bash
curl -X PUT http://localhost:3000/api/v1/dishes/1 \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Beef Adobo",
    "price": 150,
    "category": "Main Course"
  }'
```

**Request Body**:
```json
{
  "name": "Beef Adobo",
  "price": 150,
  "category": "Main Course"
}
```

**Response (200 OK)**:
```json
{
  "status": 200,
  "message": "Dish updated successfully",
  "data": { "id": 1, "name": "Beef Adobo", "price": 150, "category": "Main Course" }
}
```

---

### 5. DELETE /api/v1/dishes/:id
**Delete a dish by ID**

```bash
curl -X DELETE http://localhost:3000/api/v1/dishes/5
```

**Response (200 OK)**:
```json
{
  "status": 200,
  "message": "Dish deleted successfully",
  "data": { "id": 5, "name": "Kare-Kare", "price": 180, "category": "Main Course" }
}
```

---

## Project Structure

```
lastname-api-activity/
â”œâ”€â”€ server.js                 # Main entry point
â”œâ”€â”€ package.json             # Dependencies and scripts
â”œâ”€â”€ .env                     # Environment variables (SECRET - don't commit)
â”œâ”€â”€ .env.example            # Example env file (COMMIT THIS)
â”œâ”€â”€ .gitignore              # Git ignore rules
â”œâ”€â”€ README.md               # This file
â””â”€â”€ src/
    â”œâ”€â”€ models/
    â”‚   â””â”€â”€ dishModel.js    # Mock data for dishes
    â””â”€â”€ routes/
        â””â”€â”€ apiRoutes.js    # All CRUD route handlers
```

### File Descriptions

| File | Purpose |
|------|---------|
| `server.js` | Express app setup, middleware config, server start |
| `src/models/dishModel.js` | Mock data array (simulates database) |
| `src/routes/apiRoutes.js` | All route handlers (GET, POST, PUT, DELETE) |
| `.env` | Runtime configuration (PORT, BASE_URI) |
| `.gitignore` | Tells Git to ignore node_modules/ and .env |
| `package.json` | Project metadata and dependencies |

---

## Testing the API

### Using cURL

```bash
# Test GET all
curl http://localhost:3000/api/v1/dishes

# Test GET single
curl http://localhost:3000/api/v1/dishes/1

# Test POST (create)
curl -X POST http://localhost:3000/api/v1/dishes \
  -H "Content-Type: application/json" \
  -d '{"name":"Kare-Kare","price":180,"category":"Main Course"}'

# Test PUT (update)
curl -X PUT http://localhost:3000/api/v1/dishes/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"Beef Adobo","price":150,"category":"Main Course"}'

# Test DELETE
curl -X DELETE http://localhost:3000/api/v1/dishes/5
```

### Using Postman

1. **Create new request** â†’ Set method (GET/POST/PUT/DELETE)
2. **Enter URL**: `http://localhost:3000/api/v1/dishes`
3. **For POST/PUT**: Add Body (JSON) with dish data
4. **Send** and verify response status and data

### Manual Testing Checklist

| Action | Endpoint | Method | Expected Status |
|--------|----------|--------|-----------------|
| Get all dishes | `/api/v1/dishes` | GET | 200 |
| Get dish #1 | `/api/v1/dishes/1` | GET | 200 |
| Get non-existent | `/api/v1/dishes/999` | GET | 404 |
| Create dish | `/api/v1/dishes` | POST | 201 |
| Create without data | `/api/v1/dishes` | POST | 400 |
| Update dish | `/api/v1/dishes/1` | PUT | 200 |
| Update non-existent | `/api/v1/dishes/999` | PUT | 404 |
| Delete dish | `/api/v1/dishes/1` | DELETE | 200 |
| Delete non-existent | `/api/v1/dishes/999` | DELETE | 404 |

---

## Git Workflow

### Initialize Repository

```bash
# Initialize git
git init

# Create .gitignore
echo "node_modules/" > .gitignore
echo ".env" >> .gitignore

# Add all files
git add .

# Initial commit
git commit -m "initial: setup REST API project with CRUD operations

- Express.js server with environment configuration
- Mock dish data model
- Complete CRUD routes (GET, POST, PUT, DELETE)
- Standardized JSON responses with proper HTTP status codes
- Error handling for validation and not found scenarios
- Nodemon for development"
```

### View Commit History

```bash
git log --oneline
```

---

## Best Practices Summary

âœ… **Environment Configuration**: Using `.env` for flexible, environment-specific settings
âœ… **Resource Modeling**: Plural nouns for collections following REST conventions
âœ… **Status Codes**: Proper HTTP status codes (200, 201, 400, 404, 500)
âœ… **Consistent Responses**: All responses use standard JSON structure
âœ… **Error Handling**: Clear error messages with appropriate status codes
âœ… **Input Validation**: Checking required fields and data types
âœ… **Code Organization**: Separation of concerns (models, routes, server)
âœ… **Development Tools**: Nodemon for hot-reload during development
âœ… **Git Version Control**: Tracking changes with meaningful commits
âœ… **Documentation**: Clear README explaining the "Why" behind decisions

---

## Deployment Ready Features

- [x] Error handling for all scenarios
- [x] Input validation
- [x] CORS support
- [x] Graceful 404 handling
- [x] Environment-based configuration
- [x] Modular code structure
- [x] Comments and documentation

---

## Future Enhancements

- [ ] Database integration (MongoDB/PostgreSQL)
- [ ] Authentication & JWT tokens
- [ ] Input validation with Joi/Yup
- [ ] Pagination for GET all
- [ ] Filtering and sorting
- [ ] Unit & integration tests
- [ ] API documentation with Swagger/OpenAPI
- [ ] Rate limiting
- [ ] Logging system (Winston/Morgan)

---

## Troubleshooting

### Port Already in Use
```bash
# Change PORT in .env to 3001 or another free port
PORT=3001
npm run dev
```

### Module Not Found
```bash
# Reinstall dependencies
rm -rf node_modules
npm install
npm run dev
```

### Changes Not Reflecting
```bash
# Make sure nodemon is watching (should auto-restart on save)
# If not, stop (Ctrl+C) and restart with: npm run dev
```

---

## Submission Checklist

- [x] Code runs via `npm run dev` with no errors
- [x] All `/api/v1/dishes` routes work (GET, POST, PUT, DELETE)
- [x] Error handling implemented (400 Bad Request, 404 Not Found)
- [x] `.env` and `.gitignore` properly configured
- [x] README.md explains all "Why" questions
- [x] Git repository initialized with commits
- [x] Code ready to push to GitHub

---

## Author
[Your Name]

## Institution
Marinduque State University - College of Information and Computing Sciences

## Course
RESTful API Development Activity

## Date Completed
February 12, 2026

---

**Ready to submit! Push to GitHub and you're done.** ðŸŽ‰